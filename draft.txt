//@version=6
indicator('The Aarya Yadav Project', overlay = true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500)
//---------------------------------------------------------------------------------------------------------------------}
//CONSTANTS & STRINGS & INPUTS
//---------------------------------------------------------------------------------------------------------------------{
BULLISH_LEG                     = 1
BEARISH_LEG                     = 0

BULLISH                         = +1
BEARISH                         = -1

GREEN                           = #089981
RED                             = #F23645
BLUE                            = #2157f3
GRAY                            = #878b94
MONO_BULLISH                    = #b2b5be
MONO_BEARISH                    = #5d606b

HISTORICAL                      = 'Historical'
PRESENT                         = 'Present'

COLORED                         = 'Colored'
MONOCHROME                      = 'Monochrome'

ALL                             = 'All'
BOS                             = 'BOS'
CHOCH                           = 'CHoCH'

TINY                            = size.tiny
SMALL                           = size.small
NORMAL                          = size.normal

ATR                             = 'Atr'
RANGE                           = 'Cumulative Mean Range'

CLOSE                           = 'Close'
HIGHLOW                         = 'High/Low'

SOLID                           = '⎯⎯⎯'
DASHED                          = '----'
DOTTED                          = '····'

SMART_GROUP                     = 'Smart Money Concepts'
INTERNAL_GROUP                  = 'Real Time Internal Structure'
SWING_GROUP                     = 'Real Time Swing Structure'
BLOCKS_GROUP                    = 'Order Blocks'
EQUAL_GROUP                     = 'EQH/EQL'
GAPS_GROUP                      = 'Fair Value Gaps'
LEVELS_GROUP                    = 'Highs & Lows MTF'
ZONES_GROUP                     = 'Premium & Discount Zones'

modeTooltip                     = 'Allows to display historical Structure or only the recent ones'
styleTooltip                    = 'Indicator color theme'
showTrendTooltip                = 'Display additional candles with a color reflecting the current trend detected by structure'
showInternalsTooltip            = 'Display internal market structure'
internalFilterConfluenceTooltip = 'Filter non significant internal structure breakouts'
showStructureTooltip            = 'Display swing market Structure'
showSwingsTooltip               = 'Display swing point as labels on the chart'
showHighLowSwingsTooltip        = 'Highlight most recent strong and weak high/low points on the chart'
showInternalOrderBlocksTooltip  = 'Display internal order blocks on the chart\n\nNumber of internal order blocks to display on the chart'
showSwingOrderBlocksTooltip     = 'Display swing order blocks on the chart\n\nNumber of internal swing blocks to display on the chart'
orderBlockFilterTooltip         = 'Method used to filter out volatile order blocks \n\nIt is recommended to use the cumulative mean range method when a low amount of data is available'
orderBlockMitigationTooltip     = 'Select what values to use for order block mitigation'
showEqualHighsLowsTooltip       = 'Display equal highs and equal lows on the chart'
equalHighsLowsLengthTooltip     = 'Number of bars used to confirm equal highs and equal lows'
equalHighsLowsThresholdTooltip  = 'Sensitivity threshold in a range (0, 1) used for the detection of equal highs & lows\n\nLower values will return fewer but more pertinent results'
showFairValueGapsTooltip        = 'Display fair values gaps on the chart'
fairValueGapsThresholdTooltip   = 'Filter out non significant fair value gaps'
fairValueGapsTimeframeTooltip   = 'Fair value gaps timeframe'
fairValueGapsExtendTooltip      = 'Determine how many bars to extend the Fair Value Gap boxes on chart'
showPremiumDiscountZonesTooltip = 'Display premium, discount, and equilibrium zones on chart'

modeInput                       = input.string( HISTORICAL, 'Mode',                     group = SMART_GROUP,    tooltip = modeTooltip, options = [HISTORICAL, PRESENT])
styleInput                      = input.string( COLORED,    'Style',                    group = SMART_GROUP,    tooltip = styleTooltip,options = [COLORED, MONOCHROME])
showTrendInput                  = input(        false,      'Color Candles',            group = SMART_GROUP,    tooltip = showTrendTooltip)

showInternalsInput              = input(        true,       'Show Internal Structure',  group = INTERNAL_GROUP, tooltip = showInternalsTooltip)
showInternalBullInput           = input.string( ALL,        'Bullish Structure',        group = INTERNAL_GROUP, inline = 'ibull', options = [ALL,BOS,CHOCH])
internalBullColorInput          = input(        GREEN,      '',                         group = INTERNAL_GROUP, inline = 'ibull')
showInternalBearInput           = input.string( ALL,        'Bearish Structure' ,       group = INTERNAL_GROUP, inline = 'ibear', options = [ALL,BOS,CHOCH])
internalBearColorInput          = input(        RED,        '',                         group = INTERNAL_GROUP, inline = 'ibear')
internalFilterConfluenceInput   = input(        false,      'Confluence Filter',        group = INTERNAL_GROUP, tooltip = internalFilterConfluenceTooltip)
internalStructureSize           = input.string( TINY,       'Internal Label Size',      group = INTERNAL_GROUP, options = [TINY,SMALL,NORMAL])

showStructureInput              = input(        true,       'Show Swing Structure',     group = SWING_GROUP,    tooltip = showStructureTooltip)
showSwingBullInput              = input.string( ALL,        'Bullish Structure',        group = SWING_GROUP,    inline = 'bull',    options = [ALL,BOS,CHOCH])
swingBullColorInput             = input(        GREEN,      '',                         group = SWING_GROUP,    inline = 'bull')
showSwingBearInput              = input.string( ALL,        'Bearish Structure',        group = SWING_GROUP,    inline = 'bear',    options = [ALL,BOS,CHOCH])
swingBearColorInput             = input(        RED,        '',                         group = SWING_GROUP,    inline = 'bear')
swingStructureSize              = input.string( SMALL,      'Swing Label Size',         group = SWING_GROUP,    options = [TINY,SMALL,NORMAL])
showSwingsInput                 = input(        false,      'Show Swings Points',       group = SWING_GROUP,    tooltip = showSwingsTooltip,inline = 'swings')
swingsLengthInput               = input.int(    50,         '',                         group = SWING_GROUP,    minval = 10,                inline = 'swings')
showHighLowSwingsInput          = input(        true,       'Show Strong/Weak High/Low',group = SWING_GROUP,    tooltip = showHighLowSwingsTooltip)

showInternalOrderBlocksInput    = input(        true,       'Internal Order Blocks' ,   group = BLOCKS_GROUP,   tooltip = showInternalOrderBlocksTooltip,   inline = 'iob')
internalOrderBlocksSizeInput    = input.int(    5,          '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 20,                    inline = 'iob')
showSwingOrderBlocksInput       = input(        false,      'Swing Order Blocks',       group = BLOCKS_GROUP,   tooltip = showSwingOrderBlocksTooltip,      inline = 'ob')
swingOrderBlocksSizeInput       = input.int(    5,          '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 20,                    inline = 'ob') 
orderBlockFilterInput           = input.string( 'Atr',      'Order Block Filter',       group = BLOCKS_GROUP,   tooltip = orderBlockFilterTooltip,          options = [ATR, RANGE])
orderBlockMitigationInput       = input.string( HIGHLOW,    'Order Block Mitigation',   group = BLOCKS_GROUP,   tooltip = orderBlockMitigationTooltip,      options = [CLOSE,HIGHLOW])
internalBullishOrderBlockColor  = input.color(color.new(#3179f5, 80), 'Internal Bullish OB',    group = BLOCKS_GROUP)
internalBearishOrderBlockColor  = input.color(color.new(#f77c80, 80), 'Internal Bearish OB',    group = BLOCKS_GROUP)
swingBullishOrderBlockColor     = input.color(color.new(#1848cc, 80), 'Bullish OB',             group = BLOCKS_GROUP)
swingBearishOrderBlockColor     = input.color(color.new(#b22833, 80), 'Bearish OB',             group = BLOCKS_GROUP)

showEqualHighsLowsInput         = input(        true,       'Equal High/Low',           group = EQUAL_GROUP,    tooltip = showEqualHighsLowsTooltip)
equalHighsLowsLengthInput       = input.int(    3,          'Bars Confirmation',        group = EQUAL_GROUP,    tooltip = equalHighsLowsLengthTooltip,      minval = 1)
equalHighsLowsThresholdInput    = input.float(  0.1,        'Threshold',                group = EQUAL_GROUP,    tooltip = equalHighsLowsThresholdTooltip,   minval = 0, maxval = 0.5, step = 0.1)
equalHighsLowsSizeInput         = input.string( TINY,       'Label Size',               group = EQUAL_GROUP,    options = [TINY,SMALL,NORMAL])

showFairValueGapsInput          = input(        false,      'Fair Value Gaps',          group = GAPS_GROUP,     tooltip = showFairValueGapsTooltip)
fairValueGapsThresholdInput     = input(        true,       'Auto Threshold',           group = GAPS_GROUP,     tooltip = fairValueGapsThresholdTooltip)
fairValueGapsTimeframeInput     = input.timeframe('',       'Timeframe',                group = GAPS_GROUP,     tooltip = fairValueGapsTimeframeTooltip)
fairValueGapsBullColorInput     = input.color(color.new(#00ff68, 70), 'Bullish FVG' , group = GAPS_GROUP)
fairValueGapsBearColorInput     = input.color(color.new(#ff0008, 70), 'Bearish FVG' , group = GAPS_GROUP)
fairValueGapsExtendInput        = input.int(    1,          'Extend FVG',               group = GAPS_GROUP,     tooltip = fairValueGapsExtendTooltip,       minval = 0)

showDailyLevelsInput            = input(        false,      'Daily',    group = LEVELS_GROUP,   inline = 'daily')
dailyLevelsStyleInput           = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'daily',   options = [SOLID,DASHED,DOTTED])
dailyLevelsColorInput           = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'daily')
showWeeklyLevelsInput           = input(        false,      'Weekly',   group = LEVELS_GROUP,   inline = 'weekly')
weeklyLevelsStyleInput          = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'weekly',  options = [SOLID,DASHED,DOTTED])
weeklyLevelsColorInput          = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'weekly')
showMonthlyLevelsInput          = input(        false,      'Monthly',   group = LEVELS_GROUP,   inline = 'monthly')
monthlyLevelsStyleInput         = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'monthly', options = [SOLID,DASHED,DOTTED])
monthlyLevelsColorInput         = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'monthly')

showPremiumDiscountZonesInput   = input(        false,      'Premium/Discount Zones',   group = ZONES_GROUP , tooltip = showPremiumDiscountZonesTooltip)
premiumZoneColorInput           = input.color(  RED,        'Premium Zone',             group = ZONES_GROUP)
equilibriumZoneColorInput       = input.color(  GRAY,       'Equilibrium Zone',         group = ZONES_GROUP)
discountZoneColorInput          = input.color(  GREEN,      'Discount Zone',            group = ZONES_GROUP)

//---------------------------------------------------------------------------------------------------------------------}
//DATA STRUCTURES & VARIABLES
//---------------------------------------------------------------------------------------------------------------------{
// @type                            UDT representing alerts as bool fields
// @field internalBullishBOS        internal structure custom alert
// @field internalBearishBOS        internal structure custom alert
// @field internalBullishCHoCH      internal structure custom alert
// @field internalBearishCHoCH      internal structure custom alert
// @field swingBullishBOS           swing structure custom alert
// @field swingBearishBOS           swing structure custom alert
// @field swingBullishCHoCH         swing structure custom alert
// @field swingBearishCHoCH         swing structure custom alert
// @field internalBullishOrderBlock internal order block custom alert
// @field internalBearishOrderBlock internal order block custom alert
// @field swingBullishOrderBlock    swing order block custom alert
// @field swingBearishOrderBlock    swing order block custom alert
// @field equalHighs                equal high low custom alert
// @field equalLows                 equal high low custom alert
// @field bullishFairValueGap       fair value gap custom alert
// @field bearishFairValueGap       fair value gap custom alert
type alerts
    bool internalBullishBOS         = false
    bool internalBearishBOS         = false
    bool internalBullishCHoCH       = false
    bool internalBearishCHoCH       = false
    bool swingBullishBOS            = false
    bool swingBearishBOS            = false
    bool swingBullishCHoCH          = false
    bool swingBearishCHoCH          = false
    bool internalBullishOrderBlock  = false
    bool internalBearishOrderBlock  = false
    bool swingBullishOrderBlock     = false
    bool swingBearishOrderBlock     = false
    bool equalHighs                 = false
    bool equalLows                  = false
    bool bullishFairValueGap        = false
    bool bearishFairValueGap        = false

// @type                            UDT representing last swing extremes (top & bottom)
// @field top                       last top swing price
// @field bottom                    last bottom swing price
// @field barTime                   last swing bar time
// @field barIndex                  last swing bar index
// @field lastTopTime               last top swing time
// @field lastBottomTime            last bottom swing time
type trailingExtremes
    float top
    float bottom
    int barTime
    int barIndex
    int lastTopTime
    int lastBottomTime

// @type                            UDT representing Fair Value Gaps
// @field top                       top price
// @field bottom                    bottom price
// @field bias                      bias (BULLISH or BEARISH)
// @field topBox                    top box
// @field bottomBox                 bottom box
type fairValueGap
    float top
    float bottom
    int bias
    box topBox
    box bottomBox

// @type                            UDT representing trend bias
// @field bias                      BULLISH or BEARISH
type trend
    int bias    

// @type                            UDT representing Equal Highs Lows display
// @field l_ine                     displayed line
// @field l_abel                    displayed label
type equalDisplay
    line l_ine      = na
    label l_abel    = na

// @type                            UDT representing a pivot point (swing point) 
// @field currentLevel              current price level
// @field lastLevel                 last price level
// @field crossed                   true if price level is crossed
// @field barTime                   bar time
// @field barIndex                  bar index    
type pivot
    float currentLevel
    float lastLevel
    bool crossed
    int barTime     = time
    int barIndex    = bar_index

// @type                            UDT representing an order block
// @field barHigh                   bar high
// @field barLow                    bar low
// @field barTime                   bar time
// @field bias                      BULLISH or BEARISH
type orderBlock
    float barHigh
    float barLow
    int barTime    
    int bias

// @variable                        current swing pivot high    
var pivot swingHigh                 = pivot.new(na,na,false)
// @variable                        current swing pivot low
var pivot swingLow                  = pivot.new(na,na,false)
// @variable                        current internal pivot high
var pivot internalHigh              = pivot.new(na,na,false)
// @variable                        current internal pivot low
var pivot internalLow               = pivot.new(na,na,false)
// @variable                        current equal high pivot
var pivot equalHigh                 = pivot.new(na,na,false)
// @variable                        current equal low pivot
var pivot equalLow                  = pivot.new(na,na,false)
// @variable                        swing trend bias
var trend swingTrend                = trend.new(0)
// @variable                        internal trend bias
var trend internalTrend             = trend.new(0)
// @variable                        equal high display
var equalDisplay equalHighDisplay   = equalDisplay.new()
// @variable                        equal low display
var equalDisplay equalLowDisplay    = equalDisplay.new()
// @variable                        storage for fairValueGap UDTs
var array<fairValueGap> fairValueGaps = array.new<fairValueGap>()
// @variable                        storage for parsed highs
var array<float> parsedHighs        = array.new<float>()
// @variable                        storage for parsed lows
var array<float> parsedLows         = array.new<float>()
// @variable                        storage for raw highs
var array<float> highs              = array.new<float>()
// @variable                        storage for raw lows
var array<float> lows               = array.new<float>()
// @variable                        storage for bar time values
var array<int> times                = array.new<int>()
// @variable                        last trailing swing high and low
var trailingExtremes trailing       = trailingExtremes.new()
// @variable                                storage for orderBlock UDTs (swing order blocks)
var array<orderBlock> swingOrderBlocks      = array.new<orderBlock>()
// @variable                                storage for orderBlock UDTs (internal order blocks)
var array<orderBlock> internalOrderBlocks   = array.new<orderBlock>()
// @variable                                storage for swing order blocks boxes
var array<box> swingOrderBlocksBoxes        = array.new<box>()
// @variable                                storage for internal order blocks boxes
var array<box> internalOrderBlocksBoxes     = array.new<box>()
// @variable                        color for swing bullish structures
var swingBullishColor               = styleInput == MONOCHROME ? MONO_BULLISH : swingBullColorInput
// @variable                        color for swing bearish structures
var swingBearishColor               = styleInput == MONOCHROME ? MONO_BEARISH : swingBearColorInput
// @variable                        color for bullish fair value gaps
var fairValueGapBullishColor        = styleInput == MONOCHROME ? color.new(MONO_BULLISH,70) : fairValueGapsBullColorInput
// @variable                        color for bearish fair value gaps
var fairValueGapBearishColor        = styleInput == MONOCHROME ? color.new(MONO_BEARISH,70) : fairValueGapsBearColorInput
// @variable                        color for premium zone
var premiumZoneColor                = styleInput == MONOCHROME ? MONO_BEARISH : premiumZoneColorInput
// @variable                        color for discount zone
var discountZoneColor               = styleInput == MONOCHROME ? MONO_BULLISH : discountZoneColorInput 
// @variable                        bar index on current script iteration
varip int currentBarIndex           = bar_index
// @variable                        bar index on last script iteration
varip int lastBarIndex              = bar_index
// @variable                        alerts in current bar
alerts currentAlerts                = alerts.new()
// @variable                        time at start of chart
var initialTime                     = time

// we create the needed boxes for displaying order blocks at the first execution
if barstate.isfirst
    if showSwingOrderBlocksInput
        for index = 1 to swingOrderBlocksSizeInput
            swingOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))
    if showInternalOrderBlocksInput
        for index = 1 to internalOrderBlocksSizeInput
            internalOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))

// @variable                        source to use in bearish order blocks mitigation
bearishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : high
// @variable                        source to use in bullish order blocks mitigation
bullishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : low
// @variable                        default volatility measure
atrMeasure                          = ta.atr(200)
// @variable                        parsed volatility measure by user settings
volatilityMeasure                   = orderBlockFilterInput == ATR ? atrMeasure : ta.cum(ta.tr)/bar_index
// @variable                        true if current bar is a high volatility bar
highVolatilityBar                   = (high - low) >= (2 * volatilityMeasure)
// @variable                        parsed high
parsedHigh                          = highVolatilityBar ? low : high
// @variable                        parsed low
parsedLow                           = highVolatilityBar ? high : low

// we store current values into the arrays at each bar
parsedHighs.push(parsedHigh)
parsedLows.push(parsedLow)
highs.push(high)
lows.push(low)
times.push(time)

//---------------------------------------------------------------------------------------------------------------------}
//USER-DEFINED FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------{
// @function            Get the value of the current leg, it can be 0 (bearish) or 1 (bullish)
// @returns             int
leg(int size) =>
    var leg     = 0    
    newLegHigh  = high[size] > ta.highest( size)
    newLegLow   = low[size]  < ta.lowest(  size)
    
    if newLegHigh
        leg := BEARISH_LEG
    else if newLegLow
        leg := BULLISH_LEG
    leg

// @function            Identify whether the current value is the start of a new leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfNewLeg(int leg)      => ta.change(leg) != 0

// @function            Identify whether the current level is the start of a new bearish leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfBearishLeg(int leg)  => ta.change(leg) == -1

// @function            Identify whether the current level is the start of a new bullish leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfBullishLeg(int leg)  => ta.change(leg) == +1

// @function            create a new label
// @param labelTime     bar time coordinate
// @param labelPrice    price coordinate
// @param tag           text to display
// @param labelColor    text color
// @param labelStyle    label style
// @returns             label ID
drawLabel(int labelTime, float labelPrice, string tag, color labelColor, string labelStyle) =>    
    var label l_abel = na

    if modeInput == PRESENT
        l_abel.delete()

    l_abel := label.new(chart.point.new(labelTime,na,labelPrice),tag,xloc.bar_time,color=color(na),textcolor=labelColor,style = labelStyle,size = size.small)

// @function            create a new line and label representing an EQH or EQL
// @param p_ivot        starting pivot
// @param level         price level of current pivot
// @param size          how many bars ago was the current pivot detected
// @param equalHigh     true for EQH, false for EQL
// @returns             label ID
drawEqualHighLow(pivot p_ivot, float level, int size, bool equalHigh) =>
    equalDisplay e_qualDisplay = equalHigh ? equalHighDisplay : equalLowDisplay
    
    string tag          = 'EQL'
    color equalColor    = swingBullishColor
    string labelStyle   = label.style_label_up

    if equalHigh
        tag         := 'EQH'
        equalColor  := swingBearishColor
        labelStyle  := label.style_label_down

    if modeInput == PRESENT
        line.delete(    e_qualDisplay.l_ine)
        label.delete(   e_qualDisplay.l_abel)
        
    e_qualDisplay.l_ine     := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time[size],na,level), xloc = xloc.bar_time, color = equalColor, style = line.style_dotted)
    labelPosition           = math.round(0.5*(p_ivot.barIndex + bar_index - size))
    e_qualDisplay.l_abel    := label.new(chart.point.new(na,labelPosition,level), tag, xloc.bar_index, color = color(na), textcolor = equalColor, style = labelStyle, size = equalHighsLowsSizeInput)

// @function            store current structure and trailing swing points, and also display swing points and equal highs/lows
// @param size          (int) structure size
// @param equalHighLow  (bool) true for displaying current highs/lows
// @param internal      (bool) true for getting internal structures
// @returns             label ID
getCurrentStructure(int size,bool equalHighLow = false, bool internal = false) =>        
    currentLeg              = leg(size)
    newPivot                = startOfNewLeg(currentLeg)
    pivotLow                = startOfBullishLeg(currentLeg)
    pivotHigh               = startOfBearishLeg(currentLeg)

    if newPivot
        if pivotLow
            pivot p_ivot    = equalHighLow ? equalLow : internal ? internalLow : swingLow    

            if equalHighLow and math.abs(p_ivot.currentLevel - low[size]) < equalHighsLowsThresholdInput * atrMeasure                
                drawEqualHighLow(p_ivot, low[size], size, false)

            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := low[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]

            if not equalHighLow and not internal
                trailing.bottom         := p_ivot.currentLevel
                trailing.barTime        := p_ivot.barTime
                trailing.barIndex       := p_ivot.barIndex
                trailing.lastBottomTime := p_ivot.barTime

            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel < p_ivot.lastLevel ? 'LL' : 'HL', swingBullishColor, label.style_label_up)            
        else
            pivot p_ivot = equalHighLow ? equalHigh : internal ? internalHigh : swingHigh

            if equalHighLow and math.abs(p_ivot.currentLevel - high[size]) < equalHighsLowsThresholdInput * atrMeasure
                drawEqualHighLow(p_ivot,high[size],size,true)                

            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := high[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]

            if not equalHighLow and not internal
                trailing.top            := p_ivot.currentLevel
                trailing.barTime        := p_ivot.barTime
                trailing.barIndex       := p_ivot.barIndex
                trailing.lastTopTime    := p_ivot.barTime

            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel > p_ivot.lastLevel ? 'HH' : 'LH', swingBearishColor, label.style_label_down)
                
// @function                draw line and label representing a structure
// @param p_ivot            base pivot point
// @param tag               test to display
// @param structureColor    base color
// @param lineStyle         line style
// @param labelStyle        label style
// @param labelSize         text size
// @returns                 label ID
drawStructure(pivot p_ivot, string tag, color structureColor, string lineStyle, string labelStyle, string labelSize) =>    
    var line l_ine      = line.new(na,na,na,na,xloc = xloc.bar_time)
    var label l_abel    = label.new(na,na)

    if modeInput == PRESENT
        l_ine.delete()
        l_abel.delete()

    l_ine   := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time,na,p_ivot.currentLevel), xloc.bar_time, color=structureColor, style=lineStyle)
    l_abel  := label.new(chart.point.new(na,math.round(0.5*(p_ivot.barIndex+bar_index)),p_ivot.currentLevel), tag, xloc.bar_index, color=color(na), textcolor=structureColor, style=labelStyle, size = labelSize)

// @function            delete order blocks
// @param internal      true for internal order blocks
// @returns             orderBlock ID
deleteOrderBlocks(bool internal = false) =>
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks

    for [index,eachOrderBlock] in orderBlocks
        bool crossedOderBlock = false
        
        if bearishOrderBlockMitigationSource > eachOrderBlock.barHigh and eachOrderBlock.bias == BEARISH
            crossedOderBlock := true
            if internal
                currentAlerts.internalBearishOrderBlock := true
            else
                currentAlerts.swingBearishOrderBlock    := true
        else if bullishOrderBlockMitigationSource < eachOrderBlock.barLow and eachOrderBlock.bias == BULLISH
            crossedOderBlock := true
            if internal
                currentAlerts.internalBullishOrderBlock := true
            else
                currentAlerts.swingBullishOrderBlock    := true
        if crossedOderBlock                    
            orderBlocks.remove(index)            

// @function            fetch and store order blocks
// @param p_ivot        base pivot point
// @param internal      true for internal order blocks
// @param bias          BULLISH or BEARISH
// @returns             void
storeOrdeBlock(pivot p_ivot,bool internal = false,int bias) =>
    if (not internal and showSwingOrderBlocksInput) or (internal and showInternalOrderBlocksInput)

        array<float> a_rray = na
        int parsedIndex = na

        if bias == BEARISH
            a_rray      := parsedHighs.slice(p_ivot.barIndex,bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.max())  
        else
            a_rray      := parsedLows.slice(p_ivot.barIndex,bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.min())                        

        orderBlock o_rderBlock          = orderBlock.new(parsedHighs.get(parsedIndex), parsedLows.get(parsedIndex), times.get(parsedIndex),bias)
        array<orderBlock> orderBlocks   = internal ? internalOrderBlocks : swingOrderBlocks
        
        if orderBlocks.size() >= 100
            orderBlocks.pop()
        orderBlocks.unshift(o_rderBlock)

// @function            draw order blocks as boxes
// @param internal      true for internal order blocks
// @returns             void
drawOrderBlocks(bool internal = false) =>        
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks
    orderBlocksSize = orderBlocks.size()

    if orderBlocksSize > 0        
        maxOrderBlocks                      = internal ? internalOrderBlocksSizeInput : swingOrderBlocksSizeInput
        array<orderBlock> parsedOrdeBlocks  = orderBlocks.slice(0, math.min(maxOrderBlocks,orderBlocksSize))
        array<box> b_oxes                   = internal ? internalOrderBlocksBoxes : swingOrderBlocksBoxes        

        for [index,eachOrderBlock] in parsedOrdeBlocks
            orderBlockColor = styleInput == MONOCHROME ? (eachOrderBlock.bias == BEARISH ? color.new(MONO_BEARISH,80) : color.new(MONO_BULLISH,80)) : internal ? (eachOrderBlock.bias == BEARISH ? internalBearishOrderBlockColor : internalBullishOrderBlockColor) : (eachOrderBlock.bias == BEARISH ? swingBearishOrderBlockColor : swingBullishOrderBlockColor)

            box b_ox        = b_oxes.get(index)
            b_ox.set_top_left_point(    chart.point.new(eachOrderBlock.barTime,na,eachOrderBlock.barHigh))
            b_ox.set_bottom_right_point(chart.point.new(last_bar_time,na,eachOrderBlock.barLow))        
            b_ox.set_border_color(      internal ? na : orderBlockColor)
            b_ox.set_bgcolor(           orderBlockColor)

// @function            detect and draw structures, also detect and store order blocks
// @param internal      true for internal structures or order blocks
// @returns             void
displayStructure(bool internal = false) =>
    var bullishBar = true
    var bearishBar = true

    if internalFilterConfluenceInput
        bullishBar := high - math.max(close, open) > math.min(close, open - low)
        bearishBar := high - math.max(close, open) < math.min(close, open - low)
    
    pivot p_ivot    = internal ? internalHigh : swingHigh
    trend t_rend    = internal ? internalTrend : swingTrend

    lineStyle       = internal ? line.style_dashed : line.style_solid
    labelSize       = internal ? internalStructureSize : swingStructureSize

    extraCondition  = internal ? internalHigh.currentLevel != swingHigh.currentLevel and bullishBar : true
    bullishColor    = styleInput == MONOCHROME ? MONO_BULLISH : internal ? internalBullColorInput : swingBullColorInput

    if ta.crossover(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == BEARISH ? CHOCH : BOS

        if internal
            currentAlerts.internalBullishCHoCH  := tag == CHOCH
            currentAlerts.internalBullishBOS    := tag == BOS
        else
            currentAlerts.swingBullishCHoCH     := tag == CHOCH
            currentAlerts.swingBullishBOS       := tag == BOS

        p_ivot.crossed  := true
        t_rend.bias     := BULLISH

        displayCondition = internal ? showInternalsInput and (showInternalBullInput == ALL or (showInternalBullInput == BOS and tag != CHOCH) or (showInternalBullInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBullInput == ALL or (showSwingBullInput == BOS and tag != CHOCH) or (showSwingBullInput == CHOCH and tag == CHOCH))

        if displayCondition                        
            drawStructure(p_ivot,tag,bullishColor,lineStyle,label.style_label_down,labelSize)

        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot,internal,BULLISH)

    p_ivot          := internal ? internalLow : swingLow    
    extraCondition  := internal ? internalLow.currentLevel != swingLow.currentLevel and bearishBar : true
    bearishColor    = styleInput == MONOCHROME ? MONO_BEARISH : internal ? internalBearColorInput : swingBearColorInput

    if ta.crossunder(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == BULLISH ? CHOCH : BOS

        if internal
            currentAlerts.internalBearishCHoCH  := tag == CHOCH
            currentAlerts.internalBearishBOS    := tag == BOS
        else
            currentAlerts.swingBearishCHoCH     := tag == CHOCH
            currentAlerts.swingBearishBOS       := tag == BOS

        p_ivot.crossed := true
        t_rend.bias := BEARISH

        displayCondition = internal ? showInternalsInput and (showInternalBearInput == ALL or (showInternalBearInput == BOS and tag != CHOCH) or (showInternalBearInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBearInput == ALL or (showSwingBearInput == BOS and tag != CHOCH) or (showSwingBearInput == CHOCH and tag == CHOCH))
        
        if displayCondition                        
            drawStructure(p_ivot,tag,bearishColor,lineStyle,label.style_label_up,labelSize)

        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot,internal,BEARISH)

// @function            draw one fair value gap box (each fair value gap has two boxes)
// @param leftTime      left time coordinate
// @param rightTime     right time coordinate
// @param topPrice      top price level
// @param bottomPrice   bottom price level
// @param boxColor      box color
// @returns             box ID
fairValueGapBox(leftTime,rightTime,topPrice,bottomPrice,boxColor) => box.new(chart.point.new(leftTime,na,topPrice),chart.point.new(rightTime + fairValueGapsExtendInput * (time-time[1]),na,bottomPrice), xloc=xloc.bar_time, border_color = boxColor, bgcolor = boxColor)

// @function            delete fair value gaps
// @returns             fairValueGap ID
deleteFairValueGaps() =>
    for [index,eachFairValueGap] in fairValueGaps
        if (low < eachFairValueGap.bottom and eachFairValueGap.bias == BULLISH) or (high > eachFairValueGap.top and eachFairValueGap.bias == BEARISH)
            eachFairValueGap.topBox.delete()
            eachFairValueGap.bottomBox.delete()
            fairValueGaps.remove(index)
    
// @function            draw fair value gaps
// @returns             fairValueGap ID
drawFairValueGaps() => 
    [lastClose, lastOpen, lastTime, currentHigh, currentLow, currentTime, last2High, last2Low] = request.security(syminfo.tickerid, fairValueGapsTimeframeInput, [close[1], open[1], time[1], high[0], low[0], time[0], high[2], low[2]],lookahead = barmerge.lookahead_on)

    barDeltaPercent     = (lastClose - lastOpen) / (lastOpen * 100)
    newTimeframe        = timeframe.change(fairValueGapsTimeframeInput)
    threshold           = fairValueGapsThresholdInput ? ta.cum(math.abs(newTimeframe ? barDeltaPercent : 0)) / bar_index * 2 : 0

    bullishFairValueGap = currentLow > last2High and lastClose > last2High and barDeltaPercent > threshold and newTimeframe
    bearishFairValueGap = currentHigh < last2Low and lastClose < last2Low and -barDeltaPercent > threshold and newTimeframe

    if bullishFairValueGap
        currentAlerts.bullishFairValueGap := true
        fairValueGaps.unshift(fairValueGap.new(currentLow,last2High,BULLISH,fairValueGapBox(lastTime,currentTime,currentLow,math.avg(currentLow,last2High),fairValueGapBullishColor),fairValueGapBox(lastTime,currentTime,math.avg(currentLow,last2High),last2High,fairValueGapBullishColor)))
    if bearishFairValueGap
        currentAlerts.bearishFairValueGap := true
        fairValueGaps.unshift(fairValueGap.new(currentHigh,last2Low,BEARISH,fairValueGapBox(lastTime,currentTime,currentHigh,math.avg(currentHigh,last2Low),fairValueGapBearishColor),fairValueGapBox(lastTime,currentTime,math.avg(currentHigh,last2Low),last2Low,fairValueGapBearishColor)))

// @function            get line style from string
// @param style         line style
// @returns             string
getStyle(string style) =>
    switch style
        SOLID => line.style_solid
        DASHED => line.style_dashed
        DOTTED => line.style_dotted

// @function            draw MultiTimeFrame levels
// @param timeframe     base timeframe
// @param sameTimeframe true if chart timeframe is same as base timeframe
// @param style         line style
// @param levelColor    line and text color
// @returns             void
drawLevels(string timeframe, bool sameTimeframe, string style, color levelColor) =>
    [topLevel, bottomLevel, leftTime, rightTime] = request.security(syminfo.tickerid, timeframe, [high[1], low[1], time[1], time],lookahead = barmerge.lookahead_on)

    float parsedTop         = sameTimeframe ? high : topLevel
    float parsedBottom      = sameTimeframe ? low : bottomLevel    

    int parsedLeftTime      = sameTimeframe ? time : leftTime
    int parsedRightTime     = sameTimeframe ? time : rightTime

    int parsedTopTime       = time
    int parsedBottomTime    = time

    if not sameTimeframe
        int leftIndex               = times.binary_search_rightmost(parsedLeftTime)
        int rightIndex              = times.binary_search_rightmost(parsedRightTime)

        array<int> timeArray        = times.slice(leftIndex,rightIndex)
        array<float> topArray       = highs.slice(leftIndex,rightIndex)
        array<float> bottomArray    = lows.slice(leftIndex,rightIndex)

        parsedTopTime               := timeArray.size() > 0 ? timeArray.get(topArray.indexof(topArray.max())) : initialTime
        parsedBottomTime            := timeArray.size() > 0 ? timeArray.get(bottomArray.indexof(bottomArray.min())) : initialTime

    var line topLine        = line.new(na, na, na, na, xloc = xloc.bar_time, color = levelColor, style = getStyle(style))
    var line bottomLine     = line.new(na, na, na, na, xloc = xloc.bar_time, color = levelColor, style = getStyle(style))
    var label topLabel      = label.new(na, na, xloc = xloc.bar_time, text = str.format('P{0}H',timeframe), color=color(na), textcolor = levelColor, size = size.small, style = label.style_label_left)
    var label bottomLabel   = label.new(na, na, xloc = xloc.bar_time, text = str.format('P{0}L',timeframe), color=color(na), textcolor = levelColor, size = size.small, style = label.style_label_left)

    topLine.set_first_point(    chart.point.new(parsedTopTime,na,parsedTop))
    topLine.set_second_point(   chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedTop))   
    topLabel.set_point(         chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedTop))

    bottomLine.set_first_point( chart.point.new(parsedBottomTime,na,parsedBottom))    
    bottomLine.set_second_point(chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedBottom))
    bottomLabel.set_point(      chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedBottom))

// @function            true if chart timeframe is higher than provided timeframe
// @param timeframe     timeframe to check
// @returns             bool
higherTimeframe(string timeframe) => timeframe.in_seconds() > timeframe.in_seconds(timeframe)

// @function            update trailing swing points
// @returns             int
updateTrailingExtremes() =>
    trailing.top            := math.max(high,trailing.top)
    trailing.lastTopTime    := trailing.top == high ? time : trailing.lastTopTime
    trailing.bottom         := math.min(low,trailing.bottom)
    trailing.lastBottomTime := trailing.bottom == low ? time : trailing.lastBottomTime

// @function            draw trailing swing points
// @returns             void
drawHighLowSwings() =>
    var line topLine        = line.new(na, na, na, na, color = swingBearishColor, xloc = xloc.bar_time)
    var line bottomLine     = line.new(na, na, na, na, color = swingBullishColor, xloc = xloc.bar_time)
    var label topLabel      = label.new(na, na, color=color(na), textcolor = swingBearishColor, xloc = xloc.bar_time, style = label.style_label_down, size = size.tiny)
    var label bottomLabel   = label.new(na, na, color=color(na), textcolor = swingBullishColor, xloc = xloc.bar_time, style = label.style_label_up, size = size.tiny)

    rightTimeBar            = last_bar_time + 20 * (time - time[1])

    topLine.set_first_point(    chart.point.new(trailing.lastTopTime, na, trailing.top))
    topLine.set_second_point(   chart.point.new(rightTimeBar, na, trailing.top))
    topLabel.set_point(         chart.point.new(rightTimeBar, na, trailing.top))
    topLabel.set_text(          swingTrend.bias == BEARISH ? 'Strong High' : 'Weak High')

    bottomLine.set_first_point( chart.point.new(trailing.lastBottomTime, na, trailing.bottom))
    bottomLine.set_second_point(chart.point.new(rightTimeBar, na, trailing.bottom))
    bottomLabel.set_point(      chart.point.new(rightTimeBar, na, trailing.bottom))
    bottomLabel.set_text(       swingTrend.bias == BULLISH ? 'Strong Low' : 'Weak Low')

// @function            draw a zone with a label and a box
// @param labelLevel    price level for label
// @param labelIndex    bar index for label
// @param top           top price level for box
// @param bottom        bottom price level for box
// @param tag           text to display
// @param zoneColor     base color
// @param style         label style
// @returns             void
drawZone(float labelLevel, int labelIndex, float top, float bottom, string tag, color zoneColor, string style) =>
    var label l_abel    = label.new(na,na,text = tag, color=color(na),textcolor = zoneColor, style = style, size = size.small)
    var box b_ox        = box.new(na,na,na,na,bgcolor = color.new(zoneColor,80),border_color = color(na), xloc = xloc.bar_time)

    b_ox.set_top_left_point(    chart.point.new(trailing.barTime,na,top))
    b_ox.set_bottom_right_point(chart.point.new(last_bar_time,na,bottom))

    l_abel.set_point(           chart.point.new(na,labelIndex,labelLevel))

// @function            draw premium/discount zones
// @returns             void
drawPremiumDiscountZones() =>
    drawZone(trailing.top, math.round(0.5*(trailing.barIndex + last_bar_index)), trailing.top, 0.95*trailing.top + 0.05*trailing.bottom, 'Premium', premiumZoneColor, label.style_label_down)

    equilibriumLevel = math.avg(trailing.top, trailing.bottom)
    drawZone(equilibriumLevel, last_bar_index, 0.525*trailing.top + 0.475*trailing.bottom, 0.525*trailing.bottom + 0.475*trailing.top, 'Equilibrium', equilibriumZoneColorInput, label.style_label_left)

    drawZone(trailing.bottom, math.round(0.5*(trailing.barIndex + last_bar_index)), 0.95*trailing.bottom + 0.05*trailing.top, trailing.bottom, 'Discount', discountZoneColor, label.style_label_up)

//---------------------------------------------------------------------------------------------------------------------}
//MUTABLE VARIABLES & EXECUTION
//---------------------------------------------------------------------------------------------------------------------{
parsedOpen  = showTrendInput ? open : na
candleColor = internalTrend.bias == BULLISH ? swingBullishColor : swingBearishColor
plotcandle(parsedOpen,high,low,close,color = candleColor, wickcolor = candleColor, bordercolor = candleColor)

if showHighLowSwingsInput or showPremiumDiscountZonesInput
    updateTrailingExtremes()

    if showHighLowSwingsInput
        drawHighLowSwings()

    if showPremiumDiscountZonesInput
        drawPremiumDiscountZones()

if showFairValueGapsInput
    deleteFairValueGaps()

getCurrentStructure(swingsLengthInput,false)
getCurrentStructure(5,false,true)

if showEqualHighsLowsInput
    getCurrentStructure(equalHighsLowsLengthInput,true)

if showInternalsInput or showInternalOrderBlocksInput or showTrendInput
    displayStructure(true)

if showStructureInput or showSwingOrderBlocksInput or showHighLowSwingsInput
    displayStructure()

if showInternalOrderBlocksInput
    deleteOrderBlocks(true)

if showSwingOrderBlocksInput
    deleteOrderBlocks()

if showFairValueGapsInput
    drawFairValueGaps()

if barstate.islastconfirmedhistory or barstate.islast
    if showInternalOrderBlocksInput        
        drawOrderBlocks(true)
        
    if showSwingOrderBlocksInput        
        drawOrderBlocks()

lastBarIndex    := currentBarIndex
currentBarIndex := bar_index
newBar          = currentBarIndex != lastBarIndex

if barstate.islastconfirmedhistory or (barstate.isrealtime and newBar)
    if showDailyLevelsInput and not higherTimeframe('D')
        drawLevels('D',timeframe.isdaily,dailyLevelsStyleInput,dailyLevelsColorInput)

    if showWeeklyLevelsInput and not higherTimeframe('W')
        drawLevels('W',timeframe.isweekly,weeklyLevelsStyleInput,weeklyLevelsColorInput)

    if showMonthlyLevelsInput and not higherTimeframe('M')
        drawLevels('M',timeframe.ismonthly,monthlyLevelsStyleInput,monthlyLevelsColorInput)

//---------------------------------------------------------------------------------------------------------------------}
//ALERTS
//---------------------------------------------------------------------------------------------------------------------{
alertcondition(currentAlerts.internalBullishBOS,        'Internal Bullish BOS',         'Internal Bullish BOS formed')
alertcondition(currentAlerts.internalBullishCHoCH,      'Internal Bullish CHoCH',       'Internal Bullish CHoCH formed')
alertcondition(currentAlerts.internalBearishBOS,        'Internal Bearish BOS',         'Internal Bearish BOS formed')
alertcondition(currentAlerts.internalBearishCHoCH,      'Internal Bearish CHoCH',       'Internal Bearish CHoCH formed')

alertcondition(currentAlerts.swingBullishBOS,           'Bullish BOS',                  'Internal Bullish BOS formed')
alertcondition(currentAlerts.swingBullishCHoCH,         'Bullish CHoCH',                'Internal Bullish CHoCH formed')
alertcondition(currentAlerts.swingBearishBOS,           'Bearish BOS',                  'Bearish BOS formed')
alertcondition(currentAlerts.swingBearishCHoCH,         'Bearish CHoCH',                'Bearish CHoCH formed')

alertcondition(currentAlerts.internalBullishOrderBlock, 'Bullish Internal OB Breakout', 'Price broke bullish internal OB')
alertcondition(currentAlerts.internalBearishOrderBlock, 'Bearish Internal OB Breakout', 'Price broke bearish internal OB')
alertcondition(currentAlerts.swingBullishOrderBlock,    'Bullish Swing OB Breakout',    'Price broke bullish swing OB')
alertcondition(currentAlerts.swingBearishOrderBlock,    'Bearish Swing OB Breakout',    'Price broke bearish swing OB')

alertcondition(currentAlerts.equalHighs,                'Equal Highs',                  'Equal highs detected')
alertcondition(currentAlerts.equalLows,                 'Equal Lows',                   'Equal lows detected')

alertcondition(currentAlerts.bullishFairValueGap,       'Bullish FVG',                  'Bullish FVG formed')
alertcondition(currentAlerts.bearishFairValueGap,       'Bearish FVG',                  'Bearish FVG formed')

//---------------------------------------------------------------------------------------------------------------------}
//fvg
//Settings
//-----------------------------------------------------------------------------{
thresholdPer = input.float(0, "Threshold %", minval = 0, maxval = 100, step = .1, inline = 'threshold')
auto = input(false, "Auto", inline = 'threshold')

showLast = input.int(0, 'Unmitigated Levels', minval = 0)
mitigationLevels = input.bool(false, 'Mitigation Levels')

tf = input.timeframe('', "Timeframe")

//Style
extend = input.int(20, 'Extend', minval = 0, inline = 'extend', group = 'Style')
dynamic = input(false, 'Dynamic', inline = 'extend', group = 'Style')

bullCss = input.color(color.new(#089981, 70), "Bullish FVG", group = 'Style')
bearCss = input.color(color.new(#f23645, 70), "Bearish FVG", group = 'Style')

//Dashboard
showDash  = input(false, 'Show Dashboard', group = 'Dashboard')
dashLoc  = input.string('Top Right', 'Location', options = ['Top Right', 'Bottom Right', 'Bottom Left'], group = 'Dashboard')
textSize = input.string('Small', 'Size'        , options = ['Tiny', 'Small', 'Normal']                 , group = 'Dashboard')

//-----------------------------------------------------------------------------}
//UDT's
//-----------------------------------------------------------------------------{
type fvg
    float max
    float min
    bool  isbull
    int   t = time

//-----------------------------------------------------------------------------}
//Methods/Functions
//-----------------------------------------------------------------------------{
n = bar_index

method tosolid(color id)=> color.rgb(color.r(id),color.g(id),color.b(id))

detect() =>
    var fvg fvg_obj = na  // ✅ Proper declaration as type fvg
    threshold = auto ? ta.cum((high - low) / low) / bar_index : thresholdPer / 100

    bull_fvg = low > high[2] and close[1] > high[2] and (low - high[2]) / high[2] > threshold
    bear_fvg = high < low[2] and close[1] < low[2] and (low[2] - high) / high > threshold

    if bull_fvg
        fvg_obj := fvg.new(low, high[2], true)
    else if bear_fvg
        fvg_obj := fvg.new(low[2], high, false)

    [bull_fvg, bear_fvg, fvg_obj]


//-----------------------------------------------------------------------------}
//FVG's detection/display
//-----------------------------------------------------------------------------{
var float max_bull_fvg = na, var float min_bull_fvg = na, var bull_count = 0, var bull_mitigated = 0
var float max_bear_fvg = na, var float min_bear_fvg = na, var bear_count = 0, var bear_mitigated = 0
var t = 0

var fvg_records = array.new<fvg>(0)
var fvg_areas = array.new<box>(0)

[bull_fvg, bear_fvg, new_fvg] = request.security(syminfo.tickerid, tf, detect())

//Bull FVG's
if bull_fvg and new_fvg.t != t
    if dynamic
        max_bull_fvg := new_fvg.max
        min_bull_fvg := new_fvg.min
    
    //Populate FVG array
    if not dynamic
        fvg_areas.unshift(box.new(n-2, new_fvg.max, n+extend, new_fvg.min, na, bgcolor = bullCss))
    fvg_records.unshift(new_fvg)

    bull_count += 1
    t := new_fvg.t
else if dynamic
    max_bull_fvg := math.max(math.min(close, max_bull_fvg), min_bull_fvg)

//Bear FVG's
if bear_fvg and new_fvg.t != t
    if dynamic
        max_bear_fvg := new_fvg.max
        min_bear_fvg := new_fvg.min
    
    //Populate FVG array
    if not dynamic
        fvg_areas.unshift(box.new(n-2, new_fvg.max, n+extend, new_fvg.min, na, bgcolor = bearCss))
    fvg_records.unshift(new_fvg)

    bear_count += 1
    t := new_fvg.t
else if dynamic
    min_bear_fvg := math.min(math.max(close, min_bear_fvg), max_bear_fvg) 

//-----------------------------------------------------------------------------}
//Unmitigated/Mitigated lines
//-----------------------------------------------------------------------------{
//Test for mitigation
if fvg_records.size() > 0
    for i = fvg_records.size()-1 to 0
        get = fvg_records.get(i)

        if get.isbull
            if close < get.min
                //Display line if mitigated
                if mitigationLevels
                    line.new(get.t
                      , get.min
                      , time
                      , get.min
                      , xloc.bar_time
                      , color = bullCss
                      , style = line.style_dashed)

                //Delete box
                if not dynamic
                    area = fvg_areas.remove(i)
                    area.delete()

                fvg_records.remove(i)
                bull_mitigated += 1
        else if close > get.max
            //Display line if mitigated
            if mitigationLevels
                line.new(get.t
                  , get.max
                  , time
                  , get.max
                  , xloc.bar_time
                  , color = bearCss
                  , style = line.style_dashed)

            //Delete box
            if not dynamic
                area = fvg_areas.remove(i)
                area.delete()
            
            fvg_records.remove(i)
            bear_mitigated += 1

//Unmitigated lines
var unmitigated = array.new<line>(0)

//Remove umitigated lines 
if barstate.islast and showLast > 0 and fvg_records.size() > 0
    if unmitigated.size() > 0 
        for element in unmitigated
            element.delete()
        unmitigated.clear()

    for i = 0 to math.min(showLast-1, fvg_records.size()-1)
        get = fvg_records.get(i)

        unmitigated.push(line.new(get.t
          , get.isbull ? get.min : get.max 
          , time
          , get.isbull ? get.min : get.max
          , xloc.bar_time
          , color = get.isbull ? bullCss : bearCss))

//-----------------------------------------------------------------------------}
//Dashboard
//-----------------------------------------------------------------------------{
var table_position = dashLoc == 'Bottom Left' ? position.bottom_left 
  : dashLoc == 'Top Right' ? position.top_right 
  : position.bottom_right

var table_size = textSize == 'Tiny' ? size.tiny 
  : textSize == 'Small' ? size.small 
  : size.normal

var tb = table.new(table_position, 3, 3
  , bgcolor = #1e222d
  , border_color = #373a46
  , border_width = 1
  , frame_color = #373a46
  , frame_width = 1)

if showDash
    if barstate.isfirst
        tb.cell(1, 0, 'Bullish', text_color = bullCss.tosolid(), text_size = table_size)
        tb.cell(2, 0, 'Bearish', text_color = bearCss.tosolid(), text_size = table_size)
    
        tb.cell(0, 1, 'Count', text_size = table_size, text_color = color.white)
        tb.cell(0, 2, 'Mitigated', text_size = table_size, text_color = color.white)
    
    if barstate.islast
        tb.cell(1, 1, str.tostring(bull_count), text_color = bullCss.tosolid(), text_size = table_size)
        tb.cell(2, 1, str.tostring(bear_count), text_color = bearCss.tosolid(), text_size = table_size)
        
        tb.cell(1, 2, str.tostring(bull_mitigated / bull_count * 100, format.percent), text_color = bullCss.tosolid(), text_size = table_size)
        tb.cell(2, 2, str.tostring(bear_mitigated / bear_count * 100, format.percent), text_color = bearCss.tosolid(), text_size = table_size)

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
//Dynamic Bull FVG
max_bull_plot = plot(max_bull_fvg, color = na)
min_bull_plot = plot(min_bull_fvg, color = na)
fill(max_bull_plot, min_bull_plot, color = bullCss)

//Dynamic Bear FVG
max_bear_plot = plot(max_bear_fvg, color = na)
min_bear_plot = plot(min_bear_fvg, color = na)
fill(max_bear_plot, min_bear_plot, color = bearCss)

//-----------------------------------------------------------------------------}
//Alerts
//-----------------------------------------------------------------------------{
alertcondition(bull_count > bull_count[1], 'Bullish FVG', 'Bullish FVG detected')
alertcondition(bear_count > bear_count[1], 'Bearish FVG', 'Bearish FVG detected')

alertcondition(bull_mitigated > bull_mitigated[1], 'Bullish FVG Mitigation', 'Bullish FVG mitigated')
alertcondition(bear_mitigated > bear_mitigated[1], 'Bearish FVG Mitigation', 'Bearish FVG mitigated')

//-----------------------------------------------------------------------------}

//Support Resistance Channels

// === Settings Inputs ===
prd = input.int(defval = 10, title = "Pivot Period", minval = 4, maxval = 30, group = "Settings 🔨", tooltip = "Used while calculating Pivot Points, checks left & right bars")
ppsrc = input.string(defval = "High/Low", title = "Source", options = ["High/Low", "Close/Open"], group = "Settings 🔨", tooltip = "Source for Pivot Points")
ChannelW = input.float(defval = 5, title = "Maximum Channel Width %", minval = 1, maxval = 8, group = "Settings 🔨", tooltip = "Calculated using Highest/Lowest levels in 300 bars")
minstrength = input.int(defval = 1, title = "Minimum Strength", minval = 1, group = "Settings 🔨", tooltip = "Channel must contain at least 2 Pivot Points")
maxnumsr = input.int(defval = 6, title = "Maximum Number of S/R", minval = 1, maxval = 10, group = "Settings 🔨", tooltip = "Maximum number of Support/Resistance Channels to Show") - 1
loopback = input.int(defval = 290, title = "Loopback Period", minval = 100, maxval = 400, group = "Settings 🔨", tooltip = "While calculating S/R levels it checks Pivots in Loopback Period")

// === Color Inputs ===
res_col = input.color(defval = color.new(color.red, 75), title = "Resistance Color", group = "Colors 🟡🟢🟣")
sup_col = input.color(defval = color.new(color.lime, 75), title = "Support Color", group = "Colors 🟡🟢🟣")
inch_col = input.color(defval = color.new(color.gray, 75), title = "Color When Price in Channel", group = "Colors 🟡🟢🟣")

// === Extras ===
showpp = input.bool(defval = false, title = "Show Pivot Points", group = "Extras ⏶⏷")
showsrbroken = input.bool(defval = false, title = "Show Broken Support/Resistance", group = "Extras ⏶⏷")

// === Moving Averages ===
showthema1en = input.bool(defval = false, title = "MA 1", inline = "ma1")
showthema1len = input.int(defval = 50, title = "", inline = "ma1")
showthema1type = input.string(defval = "SMA", title = "", options = ["SMA", "EMA"], inline = "ma1")

showthema2en = input.bool(defval = false, title = "MA 2", inline = "ma2")
showthema2len = input.int(defval = 200, title = "", inline = "ma2")
showthema2type = input.string(defval = "SMA", title = "", options = ["SMA", "EMA"], inline = "ma2")


ma1 = showthema1en ? (showthema1type == "SMA" ? ta.sma(close, showthema1len) : ta.ema(close, showthema1len)) : na
ma2 = showthema2en ? (showthema2type == "SMA" ? ta.sma(close, showthema2len) : ta.ema(close, showthema2len)) : na

plot(ma1, color = not na(ma1) ? color.blue : na)
plot(ma2, color = not na(ma2) ? color.red : na)

// get Pivot High/low
float src1 =  ppsrc == 'High/Low' ? high : math.max(close, open)
float src2 =  ppsrc == 'High/Low' ? low: math.min(close, open)
float ph = ta.pivothigh(src1, prd, prd)
float pl = ta.pivotlow(src2, prd, prd) 

// Draw Pivot Points
plotshape(not na(ph) and showpp, text = "H", style = shape.labeldown, color = na, textcolor = color.red, location = location.abovebar, offset = -prd)
plotshape(not na(pl) and showpp, text = "L", style = shape.labelup, color = na, textcolor = color.lime, location = location.belowbar, offset = -prd)

//calculate maximum S/R channel width
prdhighest =  ta.highest(300)
prdlowest = ta.lowest(300)
cwidth = (prdhighest - prdlowest) * ChannelW / 100

// get/keep Pivot levels
var pivotvals= array.new_float(0)
var pivotlocs= array.new_float(0)
if (not na(ph)) or (not na(pl))
    array.unshift(pivotvals, not na(ph) ? ph : pl)
    array.unshift(pivotlocs, bar_index)
    for x = array.size(pivotvals) - 1 to 0
        if bar_index - array.get(pivotlocs, x) > loopback
            array.pop(pivotvals)
            array.pop(pivotlocs)
            continue
        break


//find/create SR channel of a pivot point
get_sr_vals(ind)=>
    float lo = array.get(pivotvals, ind)
    float hi = lo
    int numpp = 0
    for y = 0 to array.size(pivotvals) - 1
        float cpp = array.get(pivotvals, y)
        float wdth = cpp <= hi ? hi - cpp : cpp - lo
        if wdth <= cwidth // fits the max channel width?
            if cpp <= hi
                lo := math.min(lo, cpp)
            else
                hi := math.max(hi, cpp)
                
            numpp := numpp + 20 // each pivot point added as 20
    [hi, lo, numpp] 

// keep old SR channels and calculate/sort new channels if we met new pivot point
var suportresistance = array.new_float(20, 0) // min/max levels
changeit(x, y)=>
    tmp = array.get(suportresistance, y * 2)
    array.set(suportresistance, y * 2, array.get(suportresistance, x * 2))
    array.set(suportresistance, x * 2, tmp)
    tmp := array.get(suportresistance, y * 2 + 1)
    array.set(suportresistance, y * 2 + 1, array.get(suportresistance, x * 2 + 1))
    array.set(suportresistance, x * 2 + 1, tmp)
    
// Only run if either pivot high or pivot low exists
if not na(ph) or not na(pl)
    // Create or reset arrays
    supres = array.new_float(0)  // Container for strength, high, low triplets
    stren = array.new_float(10, 0)  // Placeholder strength list (can be reused)

    // Loop through all pivot points stored
    for x = 0 to array.size(pivotvals) - 1
        [hi, lo, strength] = get_sr_vals(x)  // Replace with your actual function
        array.push(supres, strength)
        array.push(supres, hi)
        array.push(supres, lo)

    
    // add each HL to strengh
    for x = 0 to array.size(pivotvals) - 1
        h = array.get(supres, x * 3 + 1)
        l = array.get(supres, x * 3 + 2)
        s = 0
        for y = 0 to loopback
            if (high[y] <= h and high[y] >= l) or
               (low[y] <= h and low[y] >= l)
                s := s + 1
        array.set(supres, x * 3, array.get(supres, x * 3) + s)
    
    //reset SR levels
    array.fill(suportresistance, 0)
    // get strongest SRs
    src = 0
    for x = 0 to array.size(pivotvals) - 1
        stv = -1. // value
        stl = -1 // location
        for y = 0 to array.size(pivotvals) - 1
            if array.get(supres, y * 3) > stv and array.get(supres, y * 3) >= minstrength * 20
                stv := array.get(supres, y * 3)
                stl := y
        if stl >= 0
            //get sr level
            hh = array.get(supres, stl * 3 + 1)
            ll = array.get(supres, stl * 3 + 2)
            array.set(suportresistance, src * 2, hh)
            array.set(suportresistance, src * 2 + 1, ll)
            array.set(stren, src, array.get(supres, stl * 3))
            
            // make included pivot points' strength zero 
            for y = 0 to array.size(pivotvals) - 1
                if (array.get(supres, y * 3 + 1) <= hh and array.get(supres, y * 3 + 1) >= ll) or
                   (array.get(supres, y * 3 + 2) <= hh and array.get(supres, y * 3 + 2) >= ll)
                    array.set(supres, y * 3, -1)

            src += 1
            if src >= 10
                break
    
    for x = 0 to 8
        for y = x + 1 to 9
            if array.get(stren, y) > array.get(stren, x)
                tmp = array.get(stren, y) 
                array.set(stren, y, array.get(stren, x))
                changeit(x, y)
                
    
get_level(ind)=>
    float ret = na
    if ind < array.size(suportresistance)
        if array.get(suportresistance, ind) != 0
            ret := array.get(suportresistance, ind)
    ret
    
get_color(ind)=>
    color ret = na
    if ind < array.size(suportresistance)
        if array.get(suportresistance, ind) != 0
            ret := array.get(suportresistance, ind) > close and array.get(suportresistance, ind + 1) > close ? res_col :
                   array.get(suportresistance, ind) < close and array.get(suportresistance, ind + 1) < close ? sup_col :
                   inch_col
    ret

var srchannels = array.new_box(10)

// On every bar:
for x = 0 to math.min(9, maxnumsr)
    // Delete old box if exists
    box.delete(array.get(srchannels, x))
    
    color srcol = get_color(x * 2)
    if not na(srcol)
        // Get the bar indexes for the left and right sides of the channel:
        // For example, use pivotlocs array to get bar indexes of the pivot points forming the channel
        // Here we fake left and right bar indexes as the min and max pivot locs in the channel for demo:
        int leftBar = na
        int rightBar = na
        
        // Find pivot bars forming this support/resistance channel
        // For simplicity, find earliest and latest pivot bar index in that channel
        float hi = array.get(suportresistance, x * 2)
        float lo = array.get(suportresistance, x * 2 + 1)
        
        leftBar := bar_index  // fallback to current bar if needed
        rightBar := bar_index + 10  // extend 10 bars forward for visibility

        // You should instead calculate leftBar and rightBar based on pivotlocs that fall between hi and lo levels
        // Example:
        int p = array.size (pivotvals)
        int earliestBar = bar_index
        int latestBar = 0
        for i = 0 to p - 1
            float pv = array.get(pivotvals, i)
            int pvBar = int(array.get(pivotlocs, i))
            if pv <= hi and pv >= lo
                earliestBar := math.min(earliestBar, pvBar)
                latestBar := math.max(latestBar, pvBar)
        if latestBar == 0
            latestBar := bar_index + 10

        leftBar := earliestBar
        rightBar := latestBar + 10  // extend 10 bars ahead for visual clarity

        array.set(srchannels, x, 
                  box.new(left = leftBar, top = hi, right = rightBar, bottom = lo, 
                          border_color = srcol, 
                          border_width = 1,
                          extend = extend.none, 
                          bgcolor = srcol))

resistancebroken = false
supportbroken = false

// check if it's not in a channel
not_in_a_channel = true
for x = 0 to math.min(9, maxnumsr)
    if close <= array.get(suportresistance, x * 2) and close >= array.get(suportresistance, x * 2 + 1) 
        not_in_a_channel := false

// if price is not in a channel then check broken ones
if not_in_a_channel
    for x = 0 to math.min(9, maxnumsr)
        if close[1] <= array.get(suportresistance, x * 2) and close > array.get(suportresistance, x * 2)
            resistancebroken := true
        if close[1] >= array.get(suportresistance, x * 2 + 1) and close < array.get(suportresistance, x * 2 + 1)
            supportbroken := true

alertcondition(resistancebroken, title = "Resistance Broken", message = "Resistance Broken")
alertcondition(supportbroken, title = "Support Broken", message = "Support Broken")
plotshape(showsrbroken and resistancebroken, style = shape.triangleup, location = location.belowbar, color = color.new(color.lime, 0), size = size.tiny)
plotshape(showsrbroken and supportbroken, style = shape.triangledown, location = location.abovebar, color = color.new(color.red, 0), size = size.tiny)

//trendlines with Breaks 
//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
length = input.int(14, 'Swing Detection Lookback')
mult = input.float(1., 'Slope', minval = 0, step = .1)
calcMethod = input.string('Atr', 'Slope Calculation Method', options = ['Atr','Stdev','Linreg'])
backpaint = input(true, tooltip = 'Backpainting offset displayed elements in the past. Disable backpainting to see real time information returned by the indicator.')

//Style
upCss = input.color(color.teal, 'Up Trendline Color', group = 'Style')
dnCss = input.color(color.red, 'Down Trendline Color', group = 'Style')
showExt = input(true, 'Show Extended Lines')

//-----------------------------------------------------------------------------}
//Calculations
//-----------------------------------------------------------------------------{
var upper = 0.
var lower = 0.
var slope_ph = 0.
var slope_pl = 0.

var offset = backpaint ? length : 0

b = bar_index
src = close

pho = ta.pivothigh(length, length)
plo = ta.pivotlow(length, length)

//Slope Calculation Method
slope = switch calcMethod
    'Atr'    => ta.atr(length) / length * mult
    'Stdev'  => ta.stdev(src,length) / length * mult
    'Linreg' => math.abs(ta.sma(src * b, length) - ta.sma(src, length) * ta.sma(b, length)) / ta.variance(b, length) / 2 * mult

// Convert series float to boolean using `not na()`
slope_ph := not na(pho) ? slope : slope_ph
slope_pl := not na(plo) ? slope : slope_pl

upper := not na(pho) ? pho : upper - slope_ph
lower := not na(plo) ? plo : lower + slope_pl

var upos = 0
var dnos = 0
upos := not na(pho) ? 0 : (close > upper - slope_ph * length ? 1 : upos)
dnos := not na(plo) ? 0 : (close < lower + slope_pl * length ? 1 : dnos)

//-----------------------------------------------------------------------------}
//Extended Lines
//-----------------------------------------------------------------------------{
var uptl  = line.new(na,na,na,na, color = upCss, style = line.style_dashed, extend = extend.right)
var dntl  = line.new(na,na,na,na, color = dnCss, style = line.style_dashed, extend = extend.right)

if not na(pho) and showExt
    uptl.set_xy1(b - offset, backpaint ? pho : upper - slope_ph * length)
    uptl.set_xy2(b - offset + 1, backpaint ? pho - slope : upper - slope_ph * (length + 1))

if not na(plo) and showExt
    dntl.set_xy1(b - offset, backpaint ? plo : lower + slope_pl * length)
    dntl.set_xy2(b - offset + 1, backpaint ? plo + slope : lower + slope_pl * (length + 1))


//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
plot(backpaint ? upper : upper - slope_ph * length, 'Upper', color = not na(pho) ? na : upCss, offset = -offset)
plot(backpaint ? lower : lower + slope_pl * length, 'Lower', color = not na(plo) ? na : dnCss, offset = -offset)


//Breakouts
plotshape(upos > upos[1] ? low : na, "Upper Break"
  , shape.labelup
  , location.absolute
  , upCss
  , text = "B"
  , textcolor = color.white
  , size = size.tiny)

plotshape(dnos > dnos[1] ? high : na, "Lower Break"
  , shape.labeldown
  , location.absolute
  , dnCss
  , text = "B"
  , textcolor = color.white
  , size = size.tiny)

//-----------------------------------------------------------------------------}
//Alerts
//-----------------------------------------------------------------------------{
alertcondition(upos > upos[1], 'Upward Breakout', 'Price broke the down-trendline upward')
alertcondition(dnos > dnos[1], 'Downward Breakout', 'Price broke the up-trendline downward')

//-----------------------------------------------------------------------------}

//MACD 

// ───── Inputs ─────
source         = input.source(close, "Source")
fastLength     = input.int(12, minval=1, title="MACD Fast MA Length")
slowLength     = input.int(26, minval=1, title="MACD Slow MA Length")
signalLength   = input.int(9, minval=1, title="MACD Signal Line Length")
veryslowLength = input.int(200, minval=1, title="Very Slow MA Length")
switchBarColor = input.bool(true, title="Enable Bar Color?")
switchMA       = input.bool(true, title="Enable Moving Averages?")
switchBG       = input.bool(true, title="Enable Background Color?")

// ───── MACD & MA Calculations ─────
fastMA     = ta.sma(source, fastLength)
slowMA     = ta.sma(source, slowLength)
veryslowMA = ta.sma(source, veryslowLength)

macd   = fastMA - slowMA
signal = ta.sma(macd, signalLength)
hist   = macd - signal

// ───── Color Logic ─────
// Calculate once per bar for consistency
crossOverHist  = ta.crossover(hist, 0)
crossUnderHist = ta.crossunder(hist, 0)

MAtrendcolor = ta.change(veryslowMA) > 0 ? color.green : color.red

// Calculate "change" values once per bar for consistency and efficiency
veryslowMA_change = ta.change(veryslowMA)
slowMA_change     = ta.change(slowMA)

trendcolor =  
     fastMA > slowMA and veryslowMA_change > 0 and close > slowMA ? color.green :
     fastMA < slowMA and veryslowMA_change < 0 and close < slowMA ? color.red :
     color.blue

bartrendcolor = 
     close > fastMA and close > slowMA and close > veryslowMA and slowMA_change > 0 ? color.green :
     close < fastMA and close < slowMA and close < veryslowMA and slowMA_change < 0 ? color.red :
     color.blue
backgroundcolor = 
     slowMA > veryslowMA and crossOverHist  and macd > 0 and fastMA > slowMA and close[slowLength] > veryslowMA ? color.green :
     slowMA < veryslowMA and crossUnderHist and macd < 0 and fastMA < slowMA and close[slowLength] < veryslowMA ? color.red :
     na

// ───── Visuals ─────

plotFast = plot(switchMA ? fastMA : na, title="Fast MA", color=trendcolor)
plotSlow = plot(switchMA ? slowMA : na, title="Slow MA", color=trendcolor, linewidth=2)
plotVerySlow = plot(switchMA ? veryslowMA : na, title="Very Slow MA", color=MAtrendcolor, linewidth=4)


// ───── Signal Logic ─────
crossOverHist_  = ta.crossover(hist, 0) 
crossUnderHist_ = ta.crossunder(hist, 0)

longSignal  = crossOverHist_  and macd > 0 and fastMA > slowMA and close[slowLength] > veryslowMA
shortSignal = crossUnderHist_ and macd < 0 and fastMA < slowMA and close[slowLength] < veryslowMA

plotshape(longSignal, title="Buy Signal", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small, text="Buy")
plotshape(shortSignal, title="Sell Signal", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small, text="Sell")

//Liquidity Sweeps 
 

//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
ls_len    = input.int(5, 'Swings', minval=1, group='Liquidity Sweeps')
ls_opt    = input.string('Only Wicks', 'options'
       , options=['Only Wicks', 'Only Outbreaks & Retest', 'Wicks + Outbreaks & Retest'], group='Liquidity Sweeps')

ls_colBl  = input.color(#089981, 'Bull ', group='Liquidity Sweeps', inline='c1')
ls_colBr  = input.color(#f23645, 'Bear' , group='Liquidity Sweeps', inline='c2')
ls_colBl2 = input.color(#08998180,  ''  , group='Liquidity Sweeps', inline='c1')
ls_colBr2 = input.color(#f2364580,  ''  , group='Liquidity Sweeps', inline='c2')

ls_extend = input.bool(true, 'Extend', group='Sweep Area') 
ls_maxB   = input.int(300, 'Max bars', minval=1, maxval=5000, group='Sweep Area')
ls_colBl3 = input.color(#08998141, 'Bull ', group='Sweep Area')
ls_colBr3 = input.color(#f2364541, 'Bear' , group='Sweep Area')

ls_oW = ls_opt == 'Only Wicks'
ls_oO = ls_opt == 'Only Outbreaks & Retest'
ls_WO = ls_opt == 'Wicks + Outbreaks & Retest'

ls_n = bar_index 

//-----------------------------------------------------------------------------}      
//UDT's
//-----------------------------------------------------------------------------{
type ls_piv
    float prc // price
    int   bix // bar_index
    bool  brk // broken
    bool  mit // mitigated
    bool  tak // taken
    bool  wic // wick
    line  lin 

type ls_boxBr 
    box  bx 
    line ln
    bool br
    int  dr

//-----------------------------------------------------------------------------}      
//Variables
//-----------------------------------------------------------------------------{
var array< ls_piv >ls_aPivH  = array.new< ls_piv >(1, ls_piv.new  ())
var array< ls_piv >ls_aPivL  = array.new< ls_piv >(1, ls_piv.new  ())
var array<ls_boxBr>ls_aBoxBr = array.new<ls_boxBr>(1, ls_boxBr.new())

//-----------------------------------------------------------------------------}      
//Methods - functions
//-----------------------------------------------------------------------------{
method ls_n(ls_piv piv) => bool out = not na(piv)

method ls_p(ls_piv piv, float val) => float out = (100 / piv.prc * val) - 100

method ls_l(ls_piv get, color c, string s='sd') => 
    style = switch s 
        'dt' => line.style_dotted
        'ds' => line.style_dashed
        =>      line.style_solid 
    line.new(get.bix, get.prc, ls_n, get.prc, color=c, style = style)

method ls_br(ls_piv get, color c3, color c, int d) =>
    y1 = d == 1 ? high : get.prc
    y2 = d == 1 ? get.prc : low
    ls_boxBr.new( 
     box.new(ls_n -1, y1, ls_n +1, y2
     , border_color
     = color.new(
       na, na   )
     , bgcolor=c3)
     , line.new(ls_n , y1, ls_n, y2, color=c, width=3)
     , false
     , d)

ls_lnDot(y, c) => line.new(ls_n, y, ls_n+3, y, color=c, style=line.style_dotted)

//-----------------------------------------------------------------------------}      
//Execution
//-----------------------------------------------------------------------------{


ls_ph = ta.pivothigh(ls_len, ls_len)
ls_pl = ta.pivotlow(ls_len, ls_len)

if not na(ls_ph)
    ls_aPivH.unshift(ls_piv.new(ls_ph, ls_n - ls_len, false, false, false, false))

if not na(ls_pl)
    ls_aPivL.unshift(ls_piv.new(ls_pl, ls_n - ls_len, false, false, false, false))

for i = ls_aPivH.size() -1 to 0
    get = ls_aPivH.get(i)
    if not get.mit
        if not get.brk
            if close > get.prc 
                if not ls_oW
                    get.brk := true
                else 
                    get.mit := true
            if not ls_oO and not get.wic 
                if high > get.prc and close < get.prc                   
                    ls_aBoxBr.unshift(get.ls_br(ls_colBr3, ls_colBr, 1))       
                    get.ls_l(ls_colBr2, 'dt'), ls_lnDot(low, ls_colBr)
                    get.wic := true  
        else 
            if close < get.prc 
                get.mit := true
            if not ls_oW and low < get.prc and close > get.prc                    
                ls_aBoxBr.unshift(get.ls_br(ls_colBl3, ls_colBl, -1))    
                get.ls_l(ls_colBl2, 'ds'), ls_lnDot(high, ls_colBl)
                get.tak := true 

    if ls_n - get.bix > 2000 or get.mit or get.tak 
        ls_aPivH.remove(i).lin.delete()

for i = ls_aPivL.size() -1 to 0
    get = ls_aPivL.get(i)
    if not get.mit
        if not get.brk
            if close < get.prc 
                if not ls_oW
                    get.brk := true
                else 
                    get.mit := true
            if not ls_oO and not get.wic 
                if low < get.prc and close > get.prc                              
                    ls_aBoxBr.unshift(get.ls_br(ls_colBl3, ls_colBl, -1))     
                    get.ls_l(ls_colBl2, 'dt'), ls_lnDot(high, ls_colBl)
                    get.wic := true 
        else 
            if close > get.prc 
                get.mit := true
            if not ls_oW and high > get.prc and close < get.prc                     
                ls_aBoxBr.unshift(get.ls_br(ls_colBr3, ls_colBr, 1))    
                get.ls_l(ls_colBr2, 'ds'), ls_lnDot(low, ls_colBr)
                get.tak := true  

    if ls_n - get.bix > 2000 or get.mit or get.tak 
        ls_aPivL.remove(i).lin.delete()

if ls_extend
    for bx in ls_aBoxBr 
        if not bx.br and ls_n - bx.bx.get_left() -1 <= ls_maxB 
            bx.bx.set_right(bar_index)
            if bx.dr == -1 and close < bx.bx.get_bottom() 
                bx.br := true 
            if bx.dr ==  1 and close > bx.bx.get_top   () 
                bx.br := true 

//-----------------------------------------------------------------------------} 
// Probability 

// === T3 Exit Signal SECTION ===
len         = input.int(2, "T3 Calculation Period")
input_src   = input.source(close, "T3 Calculation Source")
vf          = input.float(0.7, "T3 Volume Factor")
norm_period = input.int(50, "T3 Normalisation Period")
matype      = input.string("SMA", title = "T3 MA Type", options=["SMA","EMA","DEMA","TEMA","RMA","WMA","HMA","T3","ALMA","LINREG","VWMA"])
malen       = input.int(18, "T3 MA Period")

dema(_src, length) =>
    ema1 = ta.ema(_src, length)
    ema2 = ta.ema(ema1, length)
    2 * ema1 - ema2

tema(_src, length) =>
    ema1 = ta.ema(_src, length)
    ema2 = ta.ema(ema1, length)
    ema3 = ta.ema(ema2, length)
    3 * (ema1 - ema2) + ema3

t3fn(_src, length, factor) =>
    e1 = ta.ema(_src, length)
    e2 = ta.ema(e1, length)
    e3 = ta.ema(e2, length)
    e4 = ta.ema(e3, length)
    e5 = ta.ema(e4, length)
    e6 = ta.ema(e5, length)
    c1 = -factor * factor * factor
    c2 = 3 * factor * factor + 3 * factor * factor * factor
    c3 = -6 * factor * factor - 3 * factor - 3 * factor * factor * factor
    c4 = 1 + 3 * factor + factor * factor * factor + 3 * factor * factor
    c4*e6 + c3*e5 + c2*e4 + c1*e3

subject = t3fn(input_src, len, vf)
lowest  = ta.lowest(subject, norm_period)
highest = ta.highest(subject, norm_period)
plotosc = (subject - lowest) / (highest - lowest) - 0.50

f_ma(_src, _len, _type) =>
    switch _type
        "SMA"    => ta.sma(_src, _len)
        "EMA"    => ta.ema(_src, _len)
        "DEMA"   => dema(_src, _len)
        "TEMA"   => tema(_src, _len)
        "RMA"    => ta.rma(_src, _len)
        "WMA"    => ta.wma(_src, _len)
        "HMA"    => ta.hma(_src, _len)
        "T3"     => t3fn(_src, _len, 0.7)
        "ALMA"   => ta.alma(_src, _len, 0, 0.6)
        "LINREG" => ta.linreg(_src, _len, 0)
        "VWMA"   => ta.vwma(_src, _len)
        => na

sig_ma = f_ma(plotosc, malen, matype)

row_signals = array.from("Exit Long", "Exit Short", "Consider exit/TP for Long", "Consider exit/TP for Short", "Conservative Long Exit", "Conservative Short Exit")

// --- Cross logic best practice ---
crossunder_zero = ta.crossunder(plotosc, 0)
crossover_zero  = ta.crossover(plotosc, 0)
crossunder_sig  = ta.crossunder(plotosc, sig_ma)
crossover_sig   = ta.crossover(plotosc, sig_ma)

int highlight_row = na
color t3_cell_color = na
if crossunder_zero
    highlight_row := 0
    t3_cell_color := color.red
else if crossover_zero
    highlight_row := 1
    t3_cell_color := color.red
else if plotosc > 0.4
    highlight_row := 2 
    t3_cell_color := color.orange
else if plotosc < -0.4
    highlight_row := 3
    t3_cell_color := color.orange
else if crossunder_sig
    highlight_row := 4
    t3_cell_color := color.green
else if crossover_sig
    highlight_row := 5
    t3_cell_color := color.green

string t3_label   = "Exit Signal"
string t3_signal  = not na(highlight_row) ? array.get(row_signals, highlight_row) : "n/a"
color  t3_bgcolor = not na(highlight_row) ? t3_cell_color : color.gray

// === Trend Reversal Probability SECTION ===
oscPeriod = input.int(20, "Oscillator Length", minval=1, tooltip="Length for the oscillator calculation")

midpointPrice = hl2
shortSMA = ta.sma(midpointPrice, 5)
longSMA = ta.sma(midpointPrice, 34)
amazingOsc = shortSMA - longSMA

rise = ta.rma(math.max(ta.change(amazingOsc), 0), oscPeriod)
fall = ta.rma(-math.min(ta.change(amazingOsc), 0), oscPeriod)
customRSI = (fall == 0 ? 100 : rise == 0 ? 0 : 100 - (100 / (1 + rise / fall))) - 50

var durations = array.new_int()
cut = ta.barssince(ta.cross(customRSI, 0))
if cut == 0 and cut != cut[1]
    array.unshift(durations, cut[1])

float basis = array.size(durations) > 0 ? array.avg(durations) : na
float stdev = array.size(durations) > 1 ? array.stdev(durations) : na

f_cdf(float z) =>
    a1 = 0.254829592
    a2 = -0.284496736
    a3 = 1.421413741
    a4 = -1.453152027
    a5 = 1.061405429
    p = 0.3275911

    sign = z < 0 ? -1 : 1
    x = math.abs(z) / math.sqrt(2)
    t_ = 1 / (1 + p * x)  // Renamed from t to t_ to avoid shadowing
    erf_approx = 1 - (((((a5 * t_ + a4) * t_) + a3) * t_ + a2) * t_ + a1) * t_ * math.exp(-x * x)
    0.5 * (1 + sign * erf_approx)

float z = na
float probability = na
if not na(basis) and not na(stdev) and stdev != 0
    z := (cut - basis) / stdev
    probability := f_cdf(z)

probPercent = probability * 100
color prob_boxColor = na
prob_boxColor := probPercent >= 85 ? color.new(color.green, 0) : probPercent <= 15 ? color.new(color.red, 0) : color.new(color.yellow, 0)

string prob_label = "Reversal Probability"
string prob_signal = not na(probPercent) ? str.tostring(probPercent, "#.#") + "%" : "n/a"
color  prob_bgcolor = not na(probPercent) ? prob_boxColor : color.gray

// === MERGED VERTICAL TABLE ===
var table merged_table_v = table.new(position.middle_right, 2, 2, border_width=1, frame_color=color.white, border_color=color.white)

if barstate.islast
    table.clear(merged_table_v, 0, 0)
    // Row 0: T3 Exit
    table.cell(merged_table_v, 0, 0, t3_label, bgcolor=color.gray, text_color=color.white, text_size=size.normal)
    table.cell(merged_table_v, 1, 0, t3_signal, bgcolor=t3_bgcolor, text_color=color.white, text_size=size.normal)
    // Row 1: Reversal Probability
    table.cell(merged_table_v, 0, 1, prob_label, bgcolor=color.gray, text_color=color.white, text_size=size.normal)
    table.cell(merged_table_v, 1, 1, prob_signal, bgcolor=prob_bgcolor, text_color=color.white, text_size=size.huge)


//-----------------------------------------------------------------------------} 
//Volume-Based Prediction + Multi-TF EMA Trend Table
//Volume-Based Prediction + Multi-TF EMA Trend Table

// === PREDICTIONS SECTION ===
// INPUTS
int period = input.int(25, 'Prediction Period')
color color_up = input.color(color.lime, 'UP', inline = 'c')
color color_dn = input.color(#d42583, 'DOWN', inline = 'c')

// Helper function to convert delta to qualitative strength label
float high_threshold = 100000
float low_threshold  = 20000
delta_strength_text(delta) =>
    delta > high_threshold ? "Strong Bullish" :
     delta > low_threshold ? "Weak Bullish" :
     delta < -high_threshold ? "Strong Bearish" :
     delta < -low_threshold ? "Weak Bearish" : "Neutral"

// CALCULATIONS
future_trend(period, src) =>
    var color = color(na)
    var delta1 = float(na)
    var delta2 = float(na)
    var delta3 = float(na)
    var total1 = float(na)
    var total2 = float(na)
    var total3 = float(na)

    array<float> values = array.new<float>(period + 1)
    array<float> delta = array.new<float>(period + 1)
    array<chart.point> future_trend = array.new<chart.point>(period + 1)

    delta_vol = close > open ? volume : -volume

    delta1 := math.sum(delta_vol, period)
    delta2 := math.sum(delta_vol, period * 2) - delta1
    delta3 := math.sum(delta_vol, period * 3) - delta1 - delta2

    total1 := math.sum(volume, period)
    total2 := math.sum(volume, period * 2) - total1
    total3 := math.sum(volume, period * 3) - total1 - total2

    color color1 = delta1 > 0 ? color_up : color_dn
    color color2 = delta2 > 0 ? color_up : color_dn
    color color3 = delta3 > 0 ? color_up : color_dn

    if barstate.islast
        for i = 0 to period by 1
            values.set(i, math.avg(src[i], src[i + period], src[i + period * 2]))
            delta.set(i, math.avg(delta_vol[i], delta_vol[i + period], delta_vol[i + period * 2]))
        values.reverse()
        float diff = src - values.first()
        float vol_delta = delta.avg()
        for i = 0 to period by 1
            future_trend.set(i, chart.point.from_index(bar_index + i, diff + values.get(i)))
        color := vol_delta > 0 ? color_up : color_dn
        // Polyline for projection
        polyline.delete(polyline.new(future_trend, true, line_color = color, line_width = 2)[1])
        // Label: qualitative volume + predicted price
        label lb1 = label.new(future_trend.last(), style = label.style_label_left, color = color)
        lb1.set_text(delta_strength_text(vol_delta) + "\nPredicted: " + str.tostring(lb1.get_y(), '#,###.##'))
        label.delete(lb1[1])
        // Table: qualitative labels for Net Volume Δ
        table dash = table.new(position.bottom_right, 10, 10, frame_color = color, bgcolor = color.new(color, 90), frame_width = 2, border_color = color.new(chart.fg_color, 70), border_width = 1)
        dash.merge_cells(0, 0, 2, 0)
        dash.cell(0, 0, '3-Range Volume Trend Analysis', text_color = color.new(chart.fg_color, 50))
        dash.cell(0, 1, 'Metric', text_color = chart.fg_color)
        dash.cell(0, 2, 'Bars 1-' + str.tostring(period), text_color = chart.fg_color)
        dash.cell(0, 3, 'Bars ' + str.tostring(period+1) + '-' + str.tostring(period*2), text_color = chart.fg_color)
        dash.cell(0, 4, 'Bars ' + str.tostring(period*2+1) + '-' + str.tostring(period*3), text_color = chart.fg_color)
        dash.cell(1, 1, 'Net Volume Δ', text_color = chart.fg_color)
        dash.cell(2, 1, 'Total Volume', text_color = chart.fg_color)
        dash.cell(1, 2, delta_strength_text(delta1), text_color = color1, bgcolor = color.new(color1, 80))
        dash.cell(1, 3, delta_strength_text(delta2), text_color = color2, bgcolor = color.new(color2, 80))
        dash.cell(1, 4, delta_strength_text(delta3), text_color = color3, bgcolor = color.new(color3, 80))
        dash.cell(2, 2, str.tostring(total1, format.volume), text_color = chart.fg_color)
        dash.cell(2, 3, str.tostring(total2, format.volume), text_color = chart.fg_color)
        dash.cell(2, 4, str.tostring(total3, format.volume), text_color = chart.fg_color)

future_trend(period, close)

// === MULTI-TIMEFRAME EMA TREND TABLE SECTION ===
// INPUTS
tf_1d  = input.timeframe("D",    "Timeframe 1 (Day)")
tf_4h  = input.timeframe("240",  "Timeframe 2 (4H)")
tf_1h  = input.timeframe("60",   "Timeframe 3 (1H)")
tf_30m = input.timeframe("30",   "Timeframe 4 (30min)")
tf_15m = input.timeframe("15",   "Timeframe 5 (15min)")
ema_length = input.int(50, "EMA Length", minval=1)
vol_length = input.int(50, "Volume MA Length", minval=1)
strong_mult = input.float(1.5, "Strong Volume Multiplier", minval=1)
weak_mult   = input.float(0.75, "Weak Volume Multiplier", minval=0.1)

// --- EMA Trend & Volume Strength Logic
get_ema_trend_and_vol(tf) =>
    ema_value = request.security(syminfo.tickerid, tf, ta.ema(close, ema_length))
    price_value = request.security(syminfo.tickerid, tf, close)
    trend_status = price_value > ema_value ? "Bullish" : price_value < ema_value ? "Bearish" : "Neutral"
    vol_value = request.security(syminfo.tickerid, tf, volume)
    vol_ma_value = request.security(syminfo.tickerid, tf, ta.sma(volume, vol_length))
    strength_status = vol_value > vol_ma_value * strong_mult ? "Strong" :
                      vol_value < vol_ma_value * weak_mult   ? "Weak" : "Normal"
    [trend_status, strength_status]

// Get trend and volume strength for each timeframe
[trend_1d,   strength_1d]   = get_ema_trend_and_vol(tf_1d)
[trend_4h,   strength_4h]   = get_ema_trend_and_vol(tf_4h)
[trend_1h,   strength_1h]   = get_ema_trend_and_vol(tf_1h)
[trend_30m,  strength_30m]  = get_ema_trend_and_vol(tf_30m)
[trend_15m,  strength_15m]  = get_ema_trend_and_vol(tf_15m)

// Table color helpers
trend_color_func(trend_status) =>
    trend_status == "Bullish" ? color.lime :
     trend_status == "Bearish" ? color.red :
     color.gray
strength_color_func(strength_status) =>
    strength_status == "Strong" ? color.green :
     strength_status == "Weak" ? color.orange :
     color.gray

// Create the table
var table mtf_table = table.new(position.top_right, 6, 4, bgcolor=color.new(color.black, 90), frame_color=color.new(color.gray, 80), frame_width=1)
if barstate.islast
    // Headers
    table.cell(mtf_table, 0, 0, "Timeframe", text_color=color.white, bgcolor=color.new(color.gray, 65), text_size=size.normal)
    table.cell(mtf_table, 1, 0, "1D",  text_color=color.white)
    table.cell(mtf_table, 2, 0, "4H",  text_color=color.white)
    table.cell(mtf_table, 3, 0, "1H",  text_color=color.white)
    table.cell(mtf_table, 4, 0, "30m", text_color=color.white)
    table.cell(mtf_table, 5, 0, "15m", text_color=color.white)
    // Trend Row
    table.cell(mtf_table, 0, 1, "EMA Trend", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.normal)
    table.cell(mtf_table, 1, 1, trend_1d,  text_color=color.white, bgcolor=trend_color_func(trend_1d))
    table.cell(mtf_table, 2, 1, trend_4h,  text_color=color.white, bgcolor=trend_color_func(trend_4h))
    table.cell(mtf_table, 3, 1, trend_1h,  text_color=color.white, bgcolor=trend_color_func(trend_1h))
    table.cell(mtf_table, 4, 1, trend_30m, text_color=color.white, bgcolor=trend_color_func(trend_30m))
    table.cell(mtf_table, 5, 1, trend_15m, text_color=color.white, bgcolor=trend_color_func(trend_15m))
    // Volume Strength Row
    table.cell(mtf_table, 0, 2, "Vol Strength", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.normal)
    table.cell(mtf_table, 1, 2, strength_1d,  text_color=color.white, bgcolor=strength_color_func(strength_1d))
    table.cell(mtf_table, 2, 2, strength_4h,  text_color=color.white, bgcolor=strength_color_func(strength_4h))
    table.cell(mtf_table, 3, 2, strength_1h,  text_color=color.white, bgcolor=strength_color_func(strength_1h))
    table.cell(mtf_table, 4, 2, strength_30m, text_color=color.white, bgcolor=strength_color_func(strength_30m))
    table.cell(mtf_table, 5, 2, strength_15m, text_color=color.white, bgcolor=strength_color_func(strength_15m))
